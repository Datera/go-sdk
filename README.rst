Datera Golang SDK
=================

Building
--------

.. _here: http://golang.org/dl/

Requires Go 1.8+
You can download the latest version of Go here_

::

    $ make

Running Tests
-------------

::

    $ make test

Updating the entity.py file
---------------------------

If the Datera product API has been updated and the Entity structs are out of date
they can be updated in the following method.  This script can also be extended to
generate types/Classes for other languages.

::

    $ ./pschema.py -u http://${your_cluster}:7717/v2.1/api | gofmt > /src/dsdk/entity.go

Getting Started
---------------

::

    import (
        "fmt"

        // This is the sdk package
        "dsdk"
    )

    func main() {

        // First we'll get the client setup
        headers = make(map[string]string)
        client, err := dsdk.NewClient(
            "172.19.1.41", "7717", "admin", "password", "2.1", "/root", "30s", headers, false)
        if err != nil {
            panic(err)
        }

        // Now that we have the client, lets create an AppInstance
        // Each call to a SubEndpoint is done via the "GetEp" function
        ai, err := client.GetEp("app_instances").Create("name=my-app")
        if err != nil {
            panic(err)
        }

        // This call returns a genric Entity Object.  The attributes of this
        // object can be accessed in two ways

        // 1. The dynamic way via the original JSON key
        aiName := ai.Get("name").(string)
        fmt.Printf("Dynamic Name: %s\n", aiName)

        // 2. The static way via unpacking into an autogenerated object
        var myai dsdk.AppInstance
        err = json.Unmarshal(ai.GetB(), &myai)
        fmt.Printf("Static Name: %s\n", myai.Name)

        // Now lets update that AppInstance
        // You can pass two types of arguments to Create/Set/Delete functions

        // 1. "key=value" strings, both arguments MUST be strings when this form is used
        ai.Set("descr=my test label")
        ai, _ = ai.Reload()
        json.Unmarshal(ai.GetB(), &myai)
        fmt.Printf("Description: %s\n", myai.Descr)

        // 2. Give a single struct or map[string]interface{}
        var sendAi dsdk.AppInstance
        sendAi.Descr = "golden ticket"
        ai.Set(sendAi)
        ai, _ = ai.Reload()
        json.Unmarshal(ai.GetB(), &myai)
        fmt.Printf("Description2: %s\n", myai.Descr)

        // Just for fun, lets create an AppInstance, StorageInstance and Volume
        // Then online and print the connection info
        testVol := dsdk.Volume{
            Name:         "my-vol",
            Size:         5,
            ReplicaCount: 1,
        }
        testSi := dsdk.StorageInstance{
            Name:    "my-si",
            Volumes: &[]dsdk.Volume{testVol},
        }
        testAi := dsdk.AppInstance{
            Name:             "my-ai",
            StorageInstances: &[]dsdk.StorageInstance{testSi},
        }
        ai, err = client.GetEp("app_instances").Create(testAi)
        ai, err = ai.Reload()
        var myAi dsdk.AppInstance
        if err != nil {
            t.Fatalf("%s", err)
        }
        err = json.Unmarshal(ai.GetB(), &myAi)
        if err != nil {
            t.Fatalf("%s", err)
        }
        mySi := (*myAi.StorageInstances)[0]
        myVol := (*mySi.Volumes)[0]
        fmt.Printf("AI Path: %s\nSI Path: %s\nVol Path: %s\n", myAi.Path, mySi.Path, myVol.Path)

        // Get the storage_instance endpoint, send "admin_state=online" and update our struct
        sis, _ := ai.GetEp("storage_instances").List()
        si := sis[0]
        si.Set("admin_state=online")
        si, _ = si.Reload()
        json.Unmarshal(si.GetB(), &mySi)
        fmt.Printf("Access: %s", mySi.Access.(map[string]interface{}))

    }

Please consult the test files for more in depth API usage
