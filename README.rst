Datera Golang SDK
=================

Building
--------

.. _here: http://golang.org/dl/

Requires Go 1.8+
You can download the latest version of Go here_

::

    $ make

Running Tests
-------------

::

    $ make test

Updating the entity.py file
---------------------------

If the Datera product API has been updated and the Entity structs are out of date
they can be updated in the following method.  This script can also be extended to
generate types/Classes for other languages.

::

    $ ./pschema.py -u http://${your_cluster}:7717/v2.1/api | gofmt > /src/dsdk/entity.go

Getting Started
---------------

.. code:: go

    import (
        "context"
        "fmt"

        // This is the sdk package
        "dsdk"
    )

    func main() {

        // First we'll get the sdk setup
        ctxt = context.Background()
        headers = make(map[string]string)
        sdk, err := dsdk.NewSDK(
            "172.19.1.41", "7717", "admin", "password", "2.1", "/root", "30s", headers, false)
        if err != nil {
            panic(err)
        }

        // Now that we have the sdk, lets create an AppInstance
        // Each call to a SubEndpoint is done via the "GetEp" function
        ai, err := sdk.GetEp("app_instances").Create(ctxt, "name=my-app")
        if err != nil {
            panic(err)
        }

        // This call returns a genric Entity Object.  The attributes of this
        // object can be accessed in two ways

        // 1. The dynamic way via the original JSON key
        aiName := ai.Get("name").(string)
        fmt.Printf("Dynamic Name: %s\n", aiName)

        // 2. The static way via unpacking into an autogenerated object
        myai, err := dsdk.NewAppInstance(ai.GetB())
        fmt.Printf("Static Name: %s\n", myai.Name)

        // Now lets update that AppInstance
        // You can pass two types of arguments to Create/Set/Delete functions

        // 1. "key=value" strings, both arguments MUST be strings when this form is used
        ai.Set(ctxt, "descr=my test label")
        ai, _ = ai.Reload(ctxt)
        myai, err = dsdk.NewAppInstance(ai.GetB())
        fmt.Printf("Description: %s\n", myai.Descr)

        // 2. Give a single struct or map[string]interface{}
        var sendAi dsdk.AppInstance
        sendAi.Descr = "golden ticket"
        ai.Set(ctxt, sendAi)
        ai, _ = ai.Reload(ctxt)
        myai, _ = dsdk.NewAppInstance(ai.GetB())
        fmt.Printf("Description2: %s\n", myai.Descr)

        // Just for fun, lets create an AppInstance, StorageInstance and Volume
        // Then online and print the connection info
        testVol := dsdk.Volume{
            Name:         "my-vol",
            Size:         5,
            ReplicaCount: 1,
        }
        testSi := dsdk.StorageInstance{
            Name:    "my-si",
            Volumes: &[]dsdk.Volume{testVol},
        }
        testAi := dsdk.AppInstance{
            Name:             "my-ai",
            StorageInstances: &[]dsdk.StorageInstance{testSi},
        }
        ai, err = sdk.GetEp("app_instances").Create(ctxt, testAi)
        ai, err = ai.Reload(ctxt)
        if err != nil {
            t.Fatalf("%s", err)
        }
        myAi, err := dsdk.NewAppInstance(ai.GetB())
        if err != nil {
            t.Fatalf("%s", err)
        }
        mySi := (*myAi.StorageInstances)[0]
        myVol := (*mySi.Volumes)[0]
        fmt.Printf("AI Path: %s\nSI Path: %s\nVol Path: %s\n", myAi.Path, mySi.Path, myVol.Path)

        // Get the storage_instance endpoint, send "admin_state=online" and update our struct
        sis, _ := ai.GetEp("storage_instances").List(ctxt)
        si := sis[0]
        si.Set(ctxt, "admin_state=online")
        si, _ = si.Reload(ctxt)
        mySi, _ = dsdk.NewStorageInstance(si.GetB())
        fmt.Printf("Access: %s", mySi.Access)
    }

Handy Functions
---------------

.. code:: go

    // Use this function with caution.  Currently it will clean everything
    // under the configured Tenant.  This may change in the future to include
    // all tenants under the available login.
    sdk.ForceClean()

Please consult the test files for more in depth API usage
